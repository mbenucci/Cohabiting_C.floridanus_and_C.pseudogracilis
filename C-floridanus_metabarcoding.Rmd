---
title: "C_floridanus"
author: "Marco Benucci"
date: "01 June 2019"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=F}
knitr::opts_chunk$set(echo = TRUE)
```

# Environment set-up

```{r environment setup, include=F}
## R(v3.5.1 - Win)
#.libPaths(c("D:\\Dropbox\\PhD Hull\\PhD docs\\Thesis\\R_stats\\rlib3.5_win", .libPaths("D:\\Dropbox\\PhD Hull\\PhD docs\\Thesis\\R_stats\\rlib3.5_win")))

## R(v3.5.1 - OSX)
#.libPaths(c("D:\\Dropbox\\PhD Hull\\PhD docs\\Thesis\\R_stats\\rlib3.5_osx", .libPaths("D:\\Dropbox\\PhD Hull\\PhD docs\\Thesis\\R_stats\\rlib3.5_osx")))

## R(v3.5.1 - ubuntu)
.libPaths(c("/home/mb/Dropbox/PhD Hull/PhD docs/Thesis/R_stats/rlib3.5_unix", .libPaths("/home/mb/Dropbox/PhD\ Hull/PhD\ docs/Thesis/R_stats/rlib3.5_unix")))
```

```{r directory, include=FALSE}
dir()
rm(list=ls())
ls()
```

Setting up the environment for R using the following packages.

```{r packages loading, include=F}
pack.list = c("aod","ape","bipartite","boot","devtools","dplyr","EcoSimR","ggplot2","ggsignif","gplots","grid","gridExtra","iNEXT","lattice","lme4","lmtest","MASS","mgcv","msa","network","plyr","reshape2","spaa","stringi","tidyr","UpSetR","vegan","zoo")
new.packages = pack.list[!(pack.list %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages, repos="https://cran.rstudio.com")
lapply(pack.list, require, character.only=T)
```

```{r session}
sessionInfo()
```

The data used in this analysis were generated across 2 separate sequencing runs; one containing gut contentns and eDNA samples collected in May 2017, the second with samples collected in October 2017. Despite the date of the sequencing, all data frames and variable will be named after the month of collection for practicality.

```{r input_files}
infile_may17 = read.csv("data/CO1Aug17-merge-forwonly-nonchimera-c97-cov2_id97-by-taxonomy-readcounts.blast.csv", header=T)
infile_oct17 = read.csv("data/CO1DvAug18-merged-forwonly_nonchimera-c97-cov2-id97_by-taxonomy-readcounts.csv", header=T)
```

Removing the taxonomy column from each input files and saving them into separate files.

```{r removing_taxonomy}
## Custom function to format the taxonomy column

format_taxonomy <- function(input_data){
  for (t in as.data.frame(input_data)){
    n = gsub("\\['|\\']", "", t)
    i = gsub("\\'", "", n)
    taxa.split = data.frame(cbind(i))
  }
  return(taxa.split)
}

# First input file
taxa.may17 = infile_may17$taxomomy
infile_may17 = infile_may17[,!(colnames(infile_may17) %in% 'taxomomy')]

taxa.split.may = format_taxonomy(taxa.may17)
taxa.split.may = data.frame(taxa.split.may)

# Second input file
taxa.oct17 = infile_oct17$taxomomy
infile_oct17 = infile_oct17[,!(colnames(infile_oct17) %in% 'taxomomy')]

taxa.split.oct = format_taxonomy(taxa.oct17)
taxa.split.oct = data.frame(taxa.split.oct)
```

The taxonomy is saved as `.csv` file

```{r taxa_output, include=TRUE}
write.csv(taxa.split.may, "R_outputs/CO1Crang_May17_taxonomy.csv")
write.csv(taxa.split.oct, "R_outputs/CO1Crang_Oct17_taxonomy.csv")
```

Each initial input file was generated as the result of two separate taxonomic assignment operations. First DNA centroids were assigned against reference database, the DNA reads that resulted unassigned were then assigned against the NCBI nucleotide (nt) database (available at: `ftp://ftp.ncbi.nlm.nih.gov/blast/db/` - updated to early September 2018).
Each operation generated two separate files which were then merged. The following step is to remove potential duplicate taxa records that would prevent R from definying the row names with the taxa names. Because we removed the last column with the taxonomy information, we can use the whole frame; otherwise we would have needed to avoid the last column in each frame.

```{r removing duplicates}
may17.reads = as.data.frame(infile_may17 %>% group_by(X.OTU.ID) %>% summarise_all(list(sum)))
oct17.reads = as.data.frame(infile_oct17 %>% group_by(X.OTU.ID) %>% summarise_all(list(sum)))
```

Considering the sequencing runs included different experiments, we extract the columns containing headers belonging to the site in which both Crangonyx species were collected. In this case `CH` for the gut contents, and `eCH` for the kick-samples.

```{r extracting_Dv-samples}
rownames(may17.reads) = may17.reads$X.OTU.ID
rownames(oct17.reads) = oct17.reads$X.OTU.ID

may17.reads = may17.reads[,!(colnames(may17.reads)%in% 'X.OTU.ID')]
oct17.reads = oct17.reads[,!(colnames(oct17.reads)%in% 'X.OTU.ID')]

to_keep.may = grep("CH|POSITIVE|NEGATIVE", colnames(may17.reads))
may17.reads = may17.reads[,c(to_keep.may)]

to_remove.oct = grep("WB|RB|GW|pl2|pl4", colnames(oct17.reads))
oct17.reads = oct17.reads[,-to_remove.oct]
```

# 1. Initial Quality Control

To calculate sample read depth for both input files, in order to quality check the overall sequencing, first all samples that didn't sequence at all (sample N read equal to 0) need to be removed. Then the mean and standard deviation for each data set can be calculated, and quality check of the samples read depth applied. 

```{r initial read depth, include=TRUE}
colnames(may17.reads)
colnames(oct17.reads)

may17.reads = subset(may17.reads, select = colSums(may17.reads) > 0)
oct17.reads = subset(oct17.reads, select = colSums(oct17.reads) > 0)

may.depth = as.data.frame(may17.reads)
oct.depth = as.data.frame(oct17.reads)

may.depth$time = "May"
oct.depth$time = "Oct"

# Sum of DNA reads by samples to plot the sample read depth

may.depth = melt(may.depth)
may.depth = may.depth %>% group_by(time, variable) %>% summarise_all(list(sum))

oct.depth = melt(oct.depth)
oct.depth = oct.depth %>% group_by(time, variable) %>% summarise_all(list(sum))

# Joining both frames, then plotting

full.depth = rbind(may.depth, oct.depth)

ggplot(full.depth, aes(time, value)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(color=c("gray30"), alpha=0.5) +
  theme_bw() + labs(x="Data sets", y="Sample read depth (N reads)")
```


```{r mean read depth, include=F}
may17.reads = subset(may17.reads, select=colSums(may17.reads) > 0)
oct17.reads = subset(oct17.reads, select=colSums(oct17.reads) > 0)

## Mean values
mean(colSums(may17.reads))
mean(colSums(oct17.reads))

hist(colSums(may17.reads), breaks=15)
hist(colSums(oct17.reads), breaks=15)
```

```{r reads distribution, include=T, echo=F}
shapiro.test(colSums(may17.reads))
shapiro.test(colSums(oct17.reads))

t.test(colSums(may17.reads), colSums(oct17.reads), var.equal = T)
```

## Read depth threshold

The coverage filter (based on `mean(sample_DNA_reads)-sd(sample_DNA_reads)`) for the sequencing from May 2017 results negative. So we decided to use a standard 1000 reads as coverage filter. The coverage calculated for the sequencing from October 2017 instead is equal to 1902 reads.

```{r read depth filter, include=T}
cov_may17 = mean(colSums(may17.reads))-sd(colSums(may17.reads))
cov_oct17 = mean(colSums(oct17.reads))-sd(colSums(oct17.reads))

colnames(may17.reads)
colSums(may17.reads)

colnames(oct17.reads)
colSums(oct17.reads)

crang.may = subset(may17.reads, select = colSums(may17.reads) >= 1000)
crang.oct = subset(oct17.reads, select = colSums(oct17.reads) >= cov_oct17)
```

```{r boxplot after read depth QC}
may.retain = as.data.frame(crang.may)
oct.retain = as.data.frame(crang.oct)

may.retain$time = "May"
oct.retain$time = "Oct"

# Sum of DNA reads by samples to plot the sample read depth

may.retain = melt(may.retain)
may.retain = may.retain %>% group_by(time, variable) %>% summarise_all(list(sum))

oct.retain = melt(oct.retain)
oct.retain = oct.retain %>% group_by(time, variable) %>% summarise_all(list(sum))

# Joining both frames, then plotting

full.retain = rbind(may.retain, oct.retain)

ggplot(full.retain, aes(time, value)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(color=c("gray30"), alpha=0.5) +
  theme_bw() + labs(x="Data sets", y="Sample read depth (N reads)")
```

Cleaning the dataset from unwanted taxa.

```{r removing empty taxa}
crang.may = subset(crang.may, subset=rowSums(crang.may) > 0)
crang.oct = subset(crang.oct, subset=rowSums(crang.oct) > 0)

may.clean = crang.may[!(rownames(crang.may) %in% c("Chrysophyceae_sp.","Cyclostephanos_invisitatus","Dinobryon","Dinobryon_divergens","Dinophyceae","Euceraphis_betulae","Mallomonas_sp.","Melosira_ambiqua","Paraphysomonas_sp.","Penicillium_sclerotiorum","Pythium","Stephanodiscus_cf._minutulus","Thalassiosira_pseudonana","uncultured_Pythium","unassigned")),]

oct.clean = crang.oct[!(rownames(crang.oct) %in% c("Anser_anser","Ascomycota","Aves","Branta_canadensis","Cervus","Chroicocephalus_ridibundus","Chrysochromulina","Chrysochromulina_parva","Chrysophyceae_sp.","Cyclostephanos_invisitatus","Cygnus_olor","Dinophyceae","Fistulifera_pelliculosa","Fulica_atra","Gomphonema_parvulum","invertebrate_environmental_sample","Melosira_ambiqua","Mucorales","Mycena_cf._purpureofusca_MUSH159-07","Navicula_minima","Nitzschia_palea","Paraphysomonas_sp","Percidae","Pinnularia_neomajor","Rhodotorula","Stephanodiscus","Tetradesmus_obliquus","Thalassiosira_pseudonana","unassigned","uncultured_Jaminaea","uncultured_Pythium","Vanellus_vanellus","Verticillium_dahliae")),]
```

The DNA reads belonging to unwanted taxa were removed from each dataset. May dataset contained 126038 (~5.85%) reads belonging these unwanted taxa, while October dataset contained 158562 (~15.99%) reads belonging to unwanted taxa. These left us with 95.15% and 84.01% of the total reads from respectively May and October for downstream analysis.

```{r reads retained after clean up}
sum(crang.may)-sum(may.clean)
(sum(crang.may)-sum(may.clean))/sum(crang.may)*100

sum(crang.oct)-sum(oct.clean)
(sum(crang.oct)-sum(oct.clean))/sum(crang.oct)*100
```

Investigate Negative and Positive samples to see the level of contamination.

```{r contamination control}
pos.may = may.clean[,grep("POS", colnames(may.clean))]
pos.oct = oct.clean[,grep("POS", colnames(oct.clean))]

colSums(pos.may)
colSums(pos.oct)

# We remove all taxa equal to 0

pos.may = subset(pos.may, subset = rowSums(pos.may) > 0)
pos.oct = subset(pos.oct, subset = rowSums(pos.oct) > 0)

rowSums(pos.may)
rowSums(pos.oct)
```

Checking the N reads belonging to the positive Taxa _Osmia bicornis_ for both May positive samples (N reads=14867 and 39438), and October positive samples (N reads = 7284 and 4963). We detected however, also Hymeoptera taxa, which we decided to take into account as if it belonged to _O. bicornis_

```{r positive taxa}
colSums(pos.may["Osmia_bicornis",])
colSums(pos.oct["Osmia_bicornis",])

# Calculating N reads not belonging to psotive taxa
colSums(pos.may)-colSums(pos.may[c("Osmia_bicornis","Hymenoptera"),])
colSums(pos.oct)-colSums(pos.oct[c("Osmia_bicornis","Hymenoptera"),])

# Calculating ratio of contanimantion in POSITIVE samples
(colSums(pos.may)-colSums(pos.may[c("Osmia_bicornis","Hymenoptera"),]))/colSums(pos.may)
(colSums(pos.oct)-colSums(pos.oct[c("Osmia_bicornis","Hymenoptera"),]))/colSums(pos.oct)
```

Considering these values of contamination, decided to use the threshold of 0.03% for May, and of 0.39% for October. Following this step, we also applied a fied threshold of 5 reads acoss the both whole datasets. We generated pre- and post-filter to quality check the data, but we have been using the DNA reads for downstream analysis.

```{r setting threshold values}
thres.may =  0.00031
thres.oct =  0.0039
```


```{r creating pre and post filter}
may.clean = subset(may.clean[,-c(grep("POS", colnames(may.clean))),])
may.pre.filter = as.data.frame(t(may.clean))
may.pre.filter = may.pre.filter[,]/rowSums(may.pre.filter)

oct.clean = subset(oct.clean[,-c(grep("POS", colnames(oct.clean))),])
oct.pre.filter = as.data.frame(t(oct.clean))
oct.pre.filter = oct.pre.filter[,]/rowSums(oct.pre.filter)
```

```{r applying contamination threshold for May}
may.post.filter = as.data.frame(may.pre.filter)
may.post.filter[][may.post.filter <= thres.may] <- 0

may.clean = as.data.frame(t(may.clean))
may.clean[][may.clean[,]/rowSums(may.clean) <= thres.may] <- 0
#may.clean[][may.clean[,] <= 5] <- 0
```

We still detected some contamination in the Negative sample from May containing 2889 reads from _Dikerogammarus villosus_, and 71 reads from _Gammarus tigrinus_; however that threshold would be too high to be applied and still retain valid information.

```{r negative sample from May}
may.clean["NEGATIVE",]
may.clean["NEGATIVE",][may.clean["NEGATIVE",] > 0]

may.clean = subset(may.clean[-c(grep("NEG", rownames(may.clean))),])
may.pre.filter = subset(may.pre.filter[-c(grep("NEG", rownames(may.pre.filter))),])
may.post.filter = subset(may.post.filter[-c(grep("NEG", rownames(may.post.filter))),])
```

```{r saving May outputs}
## Writing pre- and post-filter data to output
write.csv(may.clean, "R_outputs/Crangonyx_May17_cleaned_reads.csv")
write.csv(may.pre.filter, "R_outputs/Crangonyx_May17_pre-filter.csv")
write.csv(may.post.filter, "R_outputs/Crangonyx_May17_post-filter.csv")
```

We didn't detect any visible contamination in the October samples, and the Negative sample was removed upstream of the contamination control.

```{r applying contamination threshold for Oct}
oct.post.filter = as.data.frame(oct.pre.filter)
oct.post.filter[][oct.post.filter <= thres.oct] <- 0

oct.clean = as.data.frame(t(oct.clean))
oct.clean[][oct.clean[,]/rowSums(oct.clean) <= thres.oct] <- 0
#oct.clean[][oct.clean[,] <= 5] <- 0
```

```{r saving October outputs}
## Writing pre- and post-filter data to output
write.csv(oct.clean, "R_outputs/Crangonyx_Oct17_cleaned_reads.csv")
write.csv(oct.pre.filter, "R_outputs/Crangonyx_Oct17_pre-filter.csv")
write.csv(oct.post.filter, "R_outputs/Crangonyx_Oct17_post-filter.csv")
```

Cleaning names, adding variables (time, location, sample_type, etc..) plus splitting eDNA from guts. Add kick-samples


```{r removing pos and neg samples plus renaming}
rownames(may.clean) = gsub("CH[.]", "CH", rownames(may.clean))
rownames(may.pre.filter) = gsub("CH[.]", "CH", rownames(may.pre.filter))
rownames(may.post.filter) = gsub("CH[.]", "CH", rownames(may.post.filter))

rownames(oct.clean) = gsub(".pl[0-9]{1}.{4,5}.nc.blast$", "", rownames(oct.clean))
rownames(oct.pre.filter) = gsub(".pl[0-9]{1}.{4,5}.nc.blast$", "", rownames(oct.pre.filter))
rownames(oct.post.filter) = gsub(".pl[0-9]{1}.{4,5}.nc.blast$", "", rownames(oct.post.filter))
```

```{r}
colSums(may.clean)
colSums(oct.clean)
```


_Dikerogammarus villosus_ contamination appears to be more problematic, since this taxa is present in multiple samples with varying levels of contaminations. Highest N reads detected for this taxa unfortunately is  was 85933 redas in sample `CH211`, corresponding to 100% of the sample.
To the best of our knowledge _D. villosus_ has not been recorded on the studied site so far, however because these samples were sequenced in conjunction with other _D. villosus_ gut contents we cannot exclude a an error during PCR. 
All specimens collected for gut contents analysis in the site were quickly identified as `Crangonyx` on field and back in the lab, and none results to be `Dikerogammarus`; plus in the kick-samples we couldn't identify any specimen belonging to the genus `Dikerogammarus` either. This points towards a probable procedural contamination due to a mis-placement of one of the samples belonging to _Dikerogammarus villosus_ gut contents analysis. We decided to remove this sample from downstream analysis.
Outside of this huge sample, we had some extra contamination from the same taxa peaking at 836 reads in `CH205` (corresponding to ~1.4% of the sample reads). Again, despite is far less than ideal, we  have to aknowledge that applying such a fixed threshold it would remove most of our prey DNA detections, which represent in most cases less than 1% of each gut contents DNA reads.
_Gammarus zaddachi_ was also present in the dataset of May with a total of 20 reads, again we suspect these might come from external contamination sources since it is outside of _G. zaddachi_ range so we are confident in accounting for that contamination but it can be removed.

```{r remaining contaminations in May}
may.clean[22,"Dikerogammarus_villosus"]
may.clean = may.clean[!c(rownames(may.clean) %in% "CH211"),]
may.post.filter = may.post.filter[!c(rownames(may.post.filter) %in% "CH211"),]

may.clean[which(may.clean$Dikerogammarus_villosus > 0),"Dikerogammarus_villosus"]
rownames(may.clean[which(may.clean$Dikerogammarus_villosus > 0),])

may.clean[which(may.clean$Gammarus_zaddachi > 0),"Gammarus_zaddachi"]
rownames(may.clean[which(may.clean$Gammarus_zaddachi > 0),])

may.clean = may.clean[,!c(colnames(may.clean) %in% c("Dikerogammarus_villosus","Gammarus_zaddachi"))]
may.post.filter = may.post.filter[,!c(colnames(may.post.filter) %in% c("Dikerogammarus_villosus","Gammarus_zaddachi"))]
```

Checking for remaining contaminations in the dataset of October. We found similar issues with _Dikerogammarus villosus_ (N reads = 27), _Gammarus zaddachi_ (N reads = 52, 52 and 77) and this time also _Homo sapiens_ (N reads = 171 and 120) contaminations. As much as these sources of contaminations should need to be accounted with a more stringent threshold, we risk of removing way too many potential prey DNA.

```{r remaining contaminations in May}
oct.clean[which(oct.clean$Dikerogammarus_villosus > 0),"Dikerogammarus_villosus"]
rownames(oct.clean[which(oct.clean$Dikerogammarus_villosus > 0),])

oct.clean[which(oct.clean$Gammarus_zaddachi > 0),"Gammarus_zaddachi"]
rownames(oct.clean[which(oct.clean$Gammarus_zaddachi > 0),])

oct.clean[which(oct.clean$Homo_sapiens > 0),"Homo_sapiens"]
rownames(oct.clean[which(oct.clean$Homo_sapiens > 0),])

oct.clean = oct.clean[,!c(colnames(oct.clean) %in% c("Dikerogammarus_villosus","Gammarus_zaddachi","Homo_sapiens"))]
oct.post.filter = oct.post.filter[,!c(colnames(oct.post.filter) %in% c("Dikerogammarus_villosus","Gammarus_zaddachi","Homo_sapiens"))]
```

# 2. eDNA and gut contents

Before continuing with data analysis we add the needed variables, and we split the data sets into gut contentns and eDNA.

```{r adding variables}
# May data set
may.clean$sample_id = rownames(may.clean)
may.clean$sample_type = "NA"
may.clean[grep("e", may.clean$sample_id, invert=T), "sample_type"] = "gut"
may.clean[grep("e", may.clean$sample_id), "sample_type"] = "eDNA"
may.clean$time = "May"
may.clean$site = gsub("[0-9]{2}$","", may.clean$sample_id)

may.post.filter$sample_id = rownames(may.post.filter)
may.post.filter$sample_type = "NA"
may.post.filter[grep("e", may.post.filter$sample_id, invert=T), "sample_type"] = "gut"
may.post.filter[grep("e", may.post.filter$sample_id), "sample_type"] = "eDNA"
may.post.filter$time = "May"
may.post.filter$site = gsub("[0-9]{2}$","", may.post.filter$sample_id)

# October data set
oct.clean$sample_id = rownames(oct.clean)
oct.clean$sample_type = "NA"
oct.clean[grep("e", oct.clean$sample_id, invert=T), "sample_type"] = "gut"
oct.clean[grep("e", oct.clean$sample_id), "sample_type"] = "eDNA"
oct.clean$time = "Oct"
oct.clean$site = gsub("[0-9]{2}$","", oct.clean$sample_id)

oct.post.filter$sample_id = rownames(oct.post.filter)
oct.post.filter$sample_type = "NA"
oct.post.filter[grep("e", oct.post.filter$sample_id, invert=T), "sample_type"] = "gut"
oct.post.filter[grep("e", oct.post.filter$sample_id), "sample_type"] = "eDNA"
oct.post.filter$time = "Oct"
oct.post.filter$site = gsub("[0-9]{2}$","", oct.post.filter$sample_id)
```

For the `predator_id`, the taxa ID was extracted from the taxa with ratio greater or equal to 90% within each samples, for both May and October. The samples that resulted still as "NA" at the end of this process were manually checked and the taxa ID were added manually.

```{r setting names of predators}
# Adding predator ID based on the DNA ratio greater than 0.9
# May
ednamay = grep("e", rownames(may.post.filter))
predmay = which(may.post.filter[-ednamay,!c(colnames(may.post.filter) %in% c("sample_id","sample_type","site","time"))] >= 0.9, arr.ind=T)

may.post.filter$predator_id = "NA"
may.post.filter[ednamay,"predator_id"] = "water"
may.post.filter[rownames(predmay),"predator_id"] = gsub("[.]?[0-9]{1,3}$", "", colnames(may.post.filter[rownames(predmay), as.vector(predmay[,2])]))

# October
ednaoct = grep("e", rownames(oct.post.filter))
predoct = which(oct.post.filter[-ednaoct,!c(colnames(oct.post.filter) %in% c("sample_id","sample_type","site","time"))] >= 0.9, arr.ind=T)

oct.post.filter$predator_id = "NA"
oct.post.filter[ednaoct,"predator_id"] = "water"
oct.post.filter[rownames(predoct),"predator_id"] = gsub("[.]?[0-9]{1,3}$", "", colnames(oct.post.filter[rownames(predoct),as.vector(predoct[,2])]))
```

Initial predator assignment was done using taxa with a proportion greater or equal to 90% of each sample. We now check thos samples that had a lower values. In May data set we managed to set all predator ids, while in October we need to sort out 22 predator ids.

```{r checking for missing predators}
# May
count(may.post.filter$predator_id == "NA")
may.clean$predator_id = may.post.filter$predator_id

# October
count(oct.post.filter$predator_id == "NA")
miss.oct = rownames(oct.post.filter[oct.post.filter$predator_id == "NA",])
miss.oct

misspred = which(oct.post.filter[miss.oct,!c(colnames(oct.post.filter) %in% c("sample_id","sample_type","site","time","predator_id"))] >= 0.8, arr.ind=T)

oct.post.filter[rownames(misspred),"predator_id"] = gsub("[.]?[0-9]{1,3}$", "", colnames(oct.post.filter[rownames(misspred), as.vector(misspred[,2])]))

count(oct.post.filter$predator_id == "NA")

# Still 6 missing that need to be manually added.
oct.post.filter$predator_id[oct.post.filter$sample_id %in% c("CH111","CH302","CH502")] = "Crangonyx_pseudogracilis"
oct.post.filter$predator_id[oct.post.filter$sample_id %in% c("CH305","CH310","CH506")] = "Crangonyx_floridanus"
oct.clean$predator_id = oct.post.filter$predator_id
```

Now that all variable have been added, the ratio and DNA reads of predators can be set to be equal to 0. This will allow further downstream analysis to calulate accurate indexes of prey diversity and diet breadth without the risk of overinflating.

```{r removing predator ratio}
# Removal of predator ratios and DNA reads
# May
m.row = rownames(may.post.filter[may.post.filter$predator_id != "water", c("site","sample_id","time","sample_type","predator_id")])
m.col = may.post.filter[may.post.filter$predator_id != "water", "predator_id"]

may.post.filter[m.row,unique(m.col)]

for (i in m.row){
  pred_id = may.post.filter[i,"predator_id"]
  pred_read = may.clean[i, "predator_id"]
  may.post.filter[i,pred_id] <- 0
  may.clean[i,pred_read] <- 0
}

# Confirming the function worked
may.post.filter[m.row,unique(m.col)]

# Oct
o.row = rownames(oct.post.filter[oct.post.filter$predator_id != "water", c("site","sample_id","time","sample_type","predator_id")])
o.col = oct.post.filter[oct.post.filter$predator_id != "water", "predator_id"]

oct.post.filter[o.row, unique(o.col)]

for (i in o.row){
  pred_id = oct.post.filter[i,"predator_id"]
  pred_read = oct.clean[i, "predator_id"]
  oct.post.filter[i,pred_id] <- 0
  oct.clean[i,pred_read] <- 0
}

# Confirming the function worked
oct.post.filter[o.row,unique(o.col)]
```

Now that predators DNA ratio have been removed, the focus can move towards the prey id. The current data are going to be saved into ".csv" files before continuing.

```{r saving files}
write.csv(may.clean, "R_outputs/May_reads_filtered.csv")
write.csv(may.post.filter, "R_outputs/May_ratio_filtered.csv")
write.csv(oct.clean, "R_outputs/Oct_reads_filtered.csv")
write.csv(oct.post.filter, "R_outputs/Oct_ratio_filtered.csv")
```

# 3. Detection of prey DNA in gut contents

Dividing gut contents and eDNA samples.

```{r separating guts and eDNA water}
guts.may = may.clean[,][may.clean$sample_type == "gut",]
edna.may = may.clean[,][may.clean$sample_type == "eDNA",]

guts.oct = oct.clean[,][oct.clean$sample_type == "gut",]
edna.oct = oct.clean[,][oct.clean$sample_type == "eDNA",]

guts.full = full_join(guts.may, guts.oct)
guts.full[is.na(guts.full)] <- 0

edna.full = full_join(edna.may, edna.oct)
edna.full[is.na(edna.full)] <- 0

# Saving gut contents and eDNA files
write.csv(guts.full, "R_outputs/gut_contents_reads.csv")
write.csv(edna.full, "R_outputs/eDNA_reads.csv")
```


```{r removing empty taxa}
# Extracting metadata
info.guts = guts.full[,c(colnames(guts.full) %in% c("time","site","sample_id","sample_type","predator_id"))]
info.edna = edna.full[,c(colnames(edna.full) %in% c("time","site","sample_id","sample_type","predator_id"))]

# Cleaning empty taxa
# gut content samples
guts.full = subset(guts.full[,!c(colnames(guts.full) %in% colnames(info.guts))], select=colSums(guts.full[,!c(colnames(guts.full) %in% colnames(info.guts))]) > 0)
# eDNA samples
edna.full = subset(edna.full[,!c(colnames(edna.full) %in% colnames(info.edna))], select=colSums(edna.full[,!c(colnames(edna.full) %in% colnames(info.edna))]) > 0)
```


```{r cleaning gut contents data frame}
# converting reads into ratio
ratio.guts = guts.full[,]/rowSums(guts.full)
ratio.guts[is.na(ratio.guts)] <- 0
ratio.guts = cbind(ratio.guts, info.guts)

melt.guts = melt(ratio.guts)

ggplot(melt.guts, aes(site, value)) +
  geom_jitter(aes(color=predator_id)) +
  facet_grid(.~time) + theme_bw() +
  ylab("prey DNA ratio") + xlab("sampling month")
```


```{r transforming into abundances}
# removing `sample_type` and `sample_id` variables and transforming detections into abundances
ratio.guts[,!c(colnames(ratio.guts) %in% c("time","site","predator_id","sample_id","sample_type"))][ratio.guts[,!c(colnames(ratio.guts) %in% c("time","site","predator_id","sample_id","sample_type"))] > 0] <- 1

abund.guts = as.data.frame(ratio.guts)
abund.guts.site = as.data.frame(abund.guts[,!c(colnames(abund.guts) %in% c("sample_id","sample_type"))] %>% group_by(time, site, predator_id) %>% summarise_all(list(sum)))

# replacing predator id with initials
abund.guts.site[grep("Crangonyx_floridanus", abund.guts.site$predator_id),"predator_id"] <- "C.flor"
abund.guts.site[grep("Crangonyx_pseudogracilis", abund.guts.site$predator_id),"predator_id"] <- "C.pseu"

abund.guts[grep("Crangonyx_floridanus", abund.guts$predator_id),"predator_id"] <- "C.flor"
abund.guts[grep("Crangonyx_pseudogracilis", abund.guts$predator_id),"predator_id"] <- "C.pseu"

# setting rownames and removing extra variables
rownames(abund.guts.site) = paste(abund.guts.site$predator_id, abund.guts.site$site, abund.guts.site$time, sep="_")
```

```{r PERMANOVA gut contents}
# comparing D.vil and G.zad
adonis.guts = abund.guts[,!c(colnames(abund.guts) %in% c("time","site","sample_type","predator_id","sample_id"))]

fact_time.guts = matrix(c(abund.guts$time), ncol=1)
fact_site.guts = matrix(c(abund.guts$site), ncol=1)
fact_predator.guts = matrix(c(abund.guts$predator_id), ncol=1)

adonis.guts = vegdist(as.matrix(adonis.guts), method = "euclidean")
adonis(adonis.guts~fact_predator.guts*fact_site.guts*fact_time.guts, permutations = 9999, method="euclidean")
```

```{r NMDS of gut contents}
meta.guts = metaMDS(adonis.guts, trymax=200, distance="euclidean")
```

```{r NMDS plot of gut contents}
# full symbols for May, hollow symbols for October
png("R_images/guts_predator_NMDS_euclidean.png", width = 3000, height = 3000, units = "px", res = 300)
plot(meta.guts, type="n", main="Crangonyx spp. gut contents NMDS", xlim=c(-1,1.5), ylim=c(-1.5,2))
points(meta.guts, select=which(fact_time.guts[,1]=="May"),col="black",pch=20)
points(meta.guts, select=which(fact_time.guts[,1]=="Oct"),col="blue",pch=1)
ordispider(meta.guts, group=fact_predator.guts[,1],col=c("blue","orange"),label=T)
ordiellipse(meta.guts, group=fact_predator.guts[,1],kind="ehull",lty=c(1,5),label=F,lwd=1)
text(1,-1,label=paste0("Stress: ",round(meta.guts$stress, 6)))
dev.off()
```

# 4. Diversity analysis of eDNA samples
To avoid over-estimating the diversity present in the eDNA samples, the data set need to be cleaned a bit further. For this purpose assignment at higher taxonomic rank (mainly Order), were removed from the dataset, while assignments to Family, were spearated from the assignments to Genus and Species level. 

```{r eDNA samples rarefaction curves}
# Removing high rank taxa
edna.full = edna.full[,!c(colnames(edna.full) %in% c("Cyclopidae","Diptera","Daphniidae"))]

# calculating ratio
edna.ratio = edna.full[]/rowSums(edna.full)
edna.ratio = cbind(edna.ratio, info.edna)

# removing `predator_id` variables and transforming eDNA detections into abundances
occup.edna = edna.ratio
occup.edna[,!c(colnames(occup.edna) %in% c("time","site","sample_id","sample_type","predator_id"))][occup.edna[,!c(colnames(occup.edna) %in% c("time","site","sample_id","sample_type","predator_id"))] > 0] <- 1

# adding genus information to help in plotting
melt.occup.edna = melt(occup.edna)
melt.occup.edna$genus = gsub("([_]{1}[A-Za-z0-9-]{+}.{+}[.]{0,1}){0,+}$","", melt.occup.edna$variable)

# Rarefaction curves calculated on abundance data without genus information
inext.edna = as.data.frame(occup.edna[,!c(colnames(occup.edna) %in% c("sample_id","sample_type","predator_id"))] %>% group_by(site, time) %>% summarise_all(list(sum)))
rownames(inext.edna) = paste(inext.edna$site, inext.edna$time, sep="_")

# removing `time`, `sample_id` and `site` variables as no more necessary.
inext.edna = t(inext.edna[,!c(colnames(inext.edna) %in% c("time","site"))])

# extrapolating rarefaction curves for Species richness and Shannon Diversity
incid.edna = iNEXT(inext.edna, q=c(0,1), datatype = "abundance", se=T, endpoint=50)

strip_labels=c("0"="Species Richness","1"="Shannon Diversity")

png("R_images/eDNA_species_rarefactions.png", width = 1000, height = 800, units = "px")
ggiNEXT(incid.edna) +
  labs(y = "", x="Number of samples") +
  theme(legend.position="right") +
  facet_grid(order~., labeller=as_labeller(strip_labels), scales="free") +
  ggtitle("Species level rarefaction curves of eDNA samples")
dev.off()
```

```{r shannon diversity in eDNA}
divers.edna = as.data.frame(occup.edna[,!c(colnames(occup.edna) %in% c("sample_type","site","predator_id"))] %>% group_by(time,sample_id) %>% summarise_all(list(sum)))

rownames(divers.edna) = paste(divers.edna$sample_id, divers.edna$time, sep="_")
sp_richness = rowSums(divers.edna[,!c(colnames(divers.edna) %in% c("sample_id","time"))])

# CH May
may_rich = sp_richness[grep("CH._May", names(sp_richness))]
mean(may_rich)
sd(may_rich)/sqrt(length(may_rich))

# CH Oct
oct_rich = sp_richness[grep("CH._Oct", names(sp_richness))]
mean(oct_rich)
sd(oct_rich)/sqrt(length(oct_rich))
```

```{r PERMANOVA eDNA}
# eDNA PERMANOVA
rownames(occup.edna)=paste(occup.edna$sample_id, occup.edna$time, sep="_")

adonis.edna = occup.edna[,!c(colnames(occup.edna) %in% c("time","site","sample_id","sample_type","predator_id"))]

fact_site.edna = matrix(c(occup.edna$site), ncol=1)
fact_time.edna = matrix(c(occup.edna$time), ncol=1)

adonis.edna = vegdist(as.matrix(adonis.edna))

adonis(adonis.edna~fact_site.edna*fact_time.edna, permutations = 9999, method="jaccard")
```

```{r nmds based on distances and on abundance data}
# NMDS based on the abundance data (will give the species scores as well)
meta.edna = metaMDS(adonis.edna, distance="jaccard")
```


```{r plotting eDNA nmds}
# full symbols for May, hollow symbols for October
png("R_images/eDNA_NMDS_jaccard.png", width = 3000, height = 3000, units = "px", res = 300)
plot(meta.edna, type="n", main="eDNA NMDS", xlim=c(-1,1.5), ylim=c(-1,1))
points(meta.edna, select=which(fact_time.edna[,1]=="May"),col="black",pch=20)
points(meta.edna, select=which(fact_time.edna[,1]=="Oct"),col="blue",pch=1)
ordispider(meta.edna, group=fact_time.edna[,1],col=c("blue","orange"),label=T)
ordiellipse(meta.edna, group=fact_time.edna[,1],kind="ehull",lty=c(1,3),label=F,lwd=1)
text(0,-1, label=paste0("Stress: ", round(meta.edna$stress, 4)))
dev.off()
```

Microscopy data from the community collected with the kick-samples are available in 6 separate files belonging to each lake from either sampling season.

```{r input files microscopy}
ch.may = read.csv("data/microscopy/CH_May.csv", sep="\t")
ch.oct = read.csv("data/microscopy/CH_Oct.csv", sep="\t")
```

Before analysis the data we remove the high rank taxa.

```{r adding the binomial}
data_structuring <- function(df){
  df = as.data.frame(df)
  df = df[,!c(colnames(df) %in% c("order","family"))]
  df = spread(df, species, abundance, fill=0)
  return(df)
}

ch.may.kick = data_structuring(ch.may)
ch.oct.kick = data_structuring(ch.oct)

# Adding variables

ch.may.kick$time = "May"
ch.oct.kick$time = "Oct"

ch.may.kick$sample_type = "kick"
ch.oct.kick$sample_type = "kick"

ch.kick = full_join(ch.may.kick, ch.oct.kick)
ch.kick[is.na(ch.kick)] <- 0
```

```{r}
ch.kick$sample_id = paste0(ch.kick$location, ch.kick$site)
```

```{r joining frames}
abund.kick = ch.kick[,!c(colnames(ch.kick) %in% "tube_id")]
colnames(abund.kick)
```

## NOTE! To sort NMDS of kick samples, try in case using occupancy but keeping individual samples separated and collapsing by time only.

```{r rarefaction curves on kick-samples}
# removing high order taxa
abund.kick = abund.kick[,!c(colnames(abund.kick) %in% c("Trichoptera","Diptera","Oligochaeta","Ostracoda","Araneae","Coleoptera","Mollusca","Zygoptera","Nematoda"))]

raref.kick = as.data.frame(abund.kick %>% group_by(site, sample_id, sample_type, time, location) %>% summarise_all(list(sum)))

# setting rownames and removing extra variables
rownames(raref.kick) = paste(raref.kick$sample_id, raref.kick$time, sep="_")
raref.kick = raref.kick[,!c(colnames(raref.kick) %in% c("site","sample_id","sample_type","time","location"))]

# list of families in data set to be removed
kick.fam = colnames(raref.kick[,grepl("idae", colnames(raref.kick)) == T])
raref.sp.kick = raref.kick[,!c(colnames(raref.kick) %in% kick.fam)]

raref.sp.kick = t(raref.sp.kick[,!c(colnames(raref.sp.kick) %in% c("site","time"))])

raref.may = raref.sp.kick[,grep("May", colnames(raref.sp.kick))]
raref.oct = raref.sp.kick[,grep("Oct", colnames(raref.sp.kick))]

#inext.kick = iNEXT(raref.sp.kick, q=c(0,1), datatype = "abundance", se=T, nboot=50, endpoint=1400)
inext.may = iNEXT(raref.may, q=c(0,1), datatype = "abundance", se=T, nboot=50, endpoint=1400)
inext.oct = iNEXT(raref.oct, q=c(0,1), datatype = "abundance", se=T, nboot=50, endpoint=1400)

strip_labels=c("0"="Species Richness","1"="Shannon Diversity")
m = ggiNEXT(inext.may) +
  labs(y = "", x="Number of individuals") +
  theme(legend.position="right") +
  facet_grid(order~., labeller=as_labeller(strip_labels), scales="free") +
  ggtitle("Rarefaction curves of communities in May kick samples")
o = ggiNEXT(inext.oct) +
  labs(y = "", x="Number of individuals") +
  theme(legend.position="right") +
  facet_grid(order~., labeller=as_labeller(strip_labels), scales="free") +
  ggtitle("Rarefaction curves of communities in Oct kick samples")

png("R_images/kick-samples_raref.png", width = 4000, height = 3000, units = "px", res = 300)
grid.arrange(m, o)
dev.off()
```

```{r species richness kick-samples}
occupancy.kick = abund.kick[,!c(colnames(abund.kick) %in% c("location"))]

occupancy.kick[,!c(colnames(occupancy.kick) %in% c("time","sample_id","site","sample_type"))][occupancy.kick[,!c(colnames(occupancy.kick) %in% c("time","sample_id","site","sample_type"))] > 0] <- 1

#grep("CH.May", paste0(occupancy.kick$sample_id, occupancy.kick$time))

rich.kick = rowSums(occupancy.kick[,!c(colnames(occupancy.kick) %in% c("sample_id","site","time","sample_type"))])

# CH May
chmay_kickrich = rich.kick[grep("CH._May", names(rich.kick))]
mean(chmay_kickrich)
sd(chmay_kickrich)/sqrt(length(chmay_kickrich))

# CH Oct
choct_kickrich = rich.kick[grep("CH._Oct", names(rich.kick))]
mean(choct_kickrich)
sd(choct_kickrich)/sqrt(length(choct_kickrich))
```


```{r PERMANOVA of kick-samples}
adonis.kick = as.data.frame(occupancy.kick[,!c(colnames(occupancy.kick) %in% c("site","sample_type"))] %>% group_by(sample_id, time) %>% summarise_all(list(sum)))

fact_site.kick = matrix(c(adonis.kick$sample_id), ncol=1)
fact_time.kick = matrix(c(adonis.kick$time), ncol=1)

rownames(adonis.kick) = paste(adonis.kick$sample_id, adonis.kick$time, sep="_")
adonis.kick = vegdist(as.matrix(adonis.kick[,!c(colnames(adonis.kick) %in% c("sample_id","time"))]))

adonis(adonis.kick~fact_site.kick*fact_time.kick, permutations = 9999, method="jaccard")
```

```{r}
meta.kick = metaMDS(adonis.kick, trymax=200, distance="jaccard")
```

```{r NMDS plot of kick-samples}
# full symbols for May, hollow symbols for October
png("R_images/kick-samples_NMDS_jaccard.png", width = 3000, height = 3000, units = "px", res = 300)
plot(meta.kick, type="n", main="kick-samples NMDS", xlim=c(-0.6,0.6), ylim=c(-0.6,0.6))
points(meta.kick, select=which(fact_time.kick[,1]=="May"),col="black",pch=20)
points(meta.kick, select=which(fact_time.kick[,1]=="Oct"),col="black",pch=1)
ordispider(meta.kick, group=fact_time.kick[,1],col=c("blue","orange"),label=T)
ordiellipse(meta.kick, group=fact_time.kick[,1],kind="ehull",lty=c(1,3),label=F,lwd=1)
text(-0.5,-0.4, label=paste0("Stress: ", round(meta.kick$stress,6)))
dev.off()
```

# 6. Community composition of eDNA and kick-samples

```{r merging kick-samples and eDNA frames}
occupancy.kick$site = occupancy.kick$sample_id
occup.edna$site = gsub("^e", "", occup.edna$site)

occup.kick.edna = full_join(occup.edna[,!c(colnames(occup.edna) %in% "predator_id")], occupancy.kick)
occup.kick.edna[is.na(occup.kick.edna)] <- 0


occup.kick.edna = as.data.frame(occup.kick.edna %>% group_by(sample_id, sample_type, site, time) %>% summarise_all(list(sum)))

adonis.kick.edna = occup.kick.edna[,!c(colnames(occup.kick.edna) %in% c("site","sample_id","sample_type","time"))]

fact_site.edki = matrix(c(occup.kick.edna$site), ncol=1)
fact_time.edki = matrix(c(occup.kick.edna$time), ncol=1)
fact_type.edki = matrix(c(occup.kick.edna$sample_type), ncol=1)

adonis(adonis.kick.edna~fact_site.edki*fact_time.edki*fact_type.edki, permutations = 9999, method = "jaccard")
```

```{r}
meta.kick.edna = metaMDS(adonis.kick.edna, trymax = 200, methods = "jaccard")
```


```{r NMDS plot of kick-samples and eDNA}
# full symbols for May, hollow symbols for October

for (s in grep("_", rownames(meta.kick.edna$species))){
  if (grepl("_sp.|cf.", rownames(meta.kick.edna$species)[s]) == T){
    rownames(meta.kick.edna$species)[s] = rownames(meta.kick.edna$species)[s]
    } else {
      rownames(meta.kick.edna$species)[s] = gsub("[a-z]{3,13}_",".", rownames(meta.kick.edna$species)[s])
    }
}

png("R_images/kick-eDNA_NMDS_jaccard.png", width = 3000, height = 3000, units = "px", res = 300)
plot(meta.kick.edna, type="n", main="Community NMDS\neDNA and kick-samples by sample type")#, xlim=c(-1.5,1.5), ylim=c(-1,1.1))
points(meta.kick.edna, select=which(fact_time.edki[,1]=="May"),col="black",pch=20)
points(meta.kick.edna, select=which(fact_time.edki[,1]=="Oct"),col="black",pch=1)
orditorp(meta.kick.edna, display="species")
ordispider(meta.kick.edna, group=fact_type.edki[,1],col=c("blue","orange"),label=T)
ordiellipse(meta.kick.edna, group=fact_type.edki[,1],kind="ehull",lty=c(1,3),label=F,lwd=1)
text(0, -1, label=paste0("Stress: ",round(meta.kick.edna$stress, 6)))
dev.off()
```

```{r envfit of communities from October}
# loading the file
water.measure = read.csv("data/env_measures/Chasewater_measures.csv", sep=",", header=T, row.names = 1)
occup.oct = occup.kick.edna[occup.kick.edna$time == "Oct",]

rownames(occup.oct) = occup.oct$sample_id

occup.oct = occup.oct[,!c(colnames(occup.oct) %in% c("time","sample_id","site","sample_type"))]

test = as.data.frame(water.measure %>% transmute(temp_mean = (temp1+temp2+temp3)/3,
                            pH_mean = (pH1+pH2+pH3)/3,
                            cond_mean = (cond1+cond2+cond3)/3))

rownames(test) = rownames(water.measure)
test.comm = as.data.frame(t(occup.oct))

sum.comm = as.data.frame(test.comm %>% transmute(CH1 = CH1,
                        CH2 = CH2+eCH2,
                        CH3 = CH3+eCH3,
                        CH4 = CH4+eCH4,
                        CH5 = CH5+eCH5,
                        CH6 = CH6))

sum.comm = as.data.frame(t(sum.comm))
colnames(sum.comm) = colnames(occup.oct)

ord = metaMDS(sum.comm, distance = "jaccard", trymax = 200)
fit.oct = envfit(ord, test, permu = 9999, na.rm=T, labels=T)
```

```{r envfit plot}
png("R_images/envift_on_October_communities.png", width = 3000, height = 3000, units = "px", res = 300)
plot(ord, type="n")
points(ord, select=which(rownames(ord$points) == c("CH1","CH2","CH3","CH4","CH5","CH6")), col="blue", pch=22)
orditorp(ord, display="sites", cex=1, col=c("blue","blue","blue","blue","blue","blue"))
orditorp(ord, display="species", type="n")
plot(fit.oct, col="red", cex=1)
dev.off()
```

#  7. Comparison of gut contents detection against community composition

```{r merging guts, and community data sets}
# Previously the sample type for the gut contents data frame was removed, so we first add it again.
abund.guts.site$sample_type = "guts"
occup.kick.edna$sample_type

occup.gut.edna.kick = full_join(abund.guts.site, occup.kick.edna)
occup.gut.edna.kick[is.na(occup.gut.edna.kick)] <- 0

adonis.guts.edna.kick = occup.gut.edna.kick[,!c(colnames(occup.gut.edna.kick) %in% c("site","sample_type","time","predator_id","sample_id"))]

fact_site.full = matrix(c(occup.gut.edna.kick$site), ncol=1)
fact_time.full = matrix(c(occup.gut.edna.kick$time), ncol=1)
fact_type.full = matrix(c(occup.gut.edna.kick$sample_type), ncol=1)

adonis.guts.edna.kick = vegdist(as.matrix(adonis.guts.edna.kick))

adonis(adonis.guts.edna.kick~fact_type.full*fact_site.full*fact_time.full, permutations = 9999, method = "jaccard")
```

```{r permanova of guts, eDNA and kick-samples}
meta.full = metaMDS(adonis.guts.edna.kick, trymax = 200, methods = "jaccard")
```


```{r NMDS plot of guts against kick-samples and eDNA}
# full symbols for May, hollow symbols for October
png("R_images/guts_community_NMDS_jaccard.png", width = 3000, height = 3000, units = "px", res = 300)
plot(meta.full, type="n", main="Gut contents and Community NMDS", xlim=c(-0.5,0.5), ylim=c(-0.6,0.7))
points(meta.full, select=which(fact_time.full[,1]=="May"),col="black",pch=20)
points(meta.full, select=which(fact_time.full[,1]=="Oct"),col="black",pch=1)
ordispider(meta.full, group=fact_type.full[,1],col=c("blue","orange","green"),label=T)
ordiellipse(meta.full, group=fact_type.full[,1],kind="ehull",lty=c(1,5,3),label=F,lwd=1)
text(0, -0.5, label=paste0("Stress: ",round(meta.full$stress, 6)))
dev.off()
```

```{r}
colnames(occup.gut.edna.kick)

#which(occup.gut.edna.kick$Chrysophyceae_sp. > 0)

#occup.gut.edna.kick[which(occup.gut.edna.kick$Chrysophyceae_sp. > 0),c("sample_type","time")]
```


```{r barplot of guts and community}
occup.melt = melt(occup.gut.edna.kick)

# Adding order groups to the data frame
occup.melt$order = "NA"
occup.melt[grep("Hydracarina|Limnesia|Platynothrus", occup.melt$variable),"order"] = "Arachnida"
occup.melt[grep("Chydorus|Daphnia|Diaphanosoma|Eurycercus|Polyphemus|Sida", occup.melt$variable),"order"] = "Cladocera"
occup.melt[grep("Cyclops|Eucyclops|Eudiaptomus|Maxillopoda|Mesocyclops", occup.melt$variable), "order"] = "Cyclopoida"
occup.melt[grep("Agabus|Dryopidae|Haliplus|Hyphydrus|Limnius|Platambus", occup.melt$variable), "order"] = "Coleoptera"
occup.melt[grep("Asellus", occup.melt$variable), "order"] = "Isopoda"
occup.melt[grep("Corophium|Crangonyx", occup.melt$variable), "order"] = "Amphipoda"
occup.melt[grep("Ceratopogonidae|Chironomidae|Cricotopus|Endochironomus|Limoniidae|Polypedilum|Stratiomys|Tabanidae|Tipulidae", occup.melt$variable), "order"]= "Diptera"
occup.melt[grep("Caenis|Procleon", occup.melt$variable), "order"] = "Ephemeroptera"
occup.melt[grep("Corixidae", occup.melt$variable), "order"] = "Hemiptera"
occup.melt[grep("Bereobdella|Erpobdella|Glossiphonia|Haemopis|Helobdella", occup.melt$variable), "order"] = "Hirudinea"
occup.melt[grep("Hydra", occup.melt$variable), "order"] = "Hydrozoa"
occup.melt[grep("Bithynia|Dreissena|Lymnaea|Pisidium|Planorbis|Potamopyrgus|Segmentina|Sphaerium|Valvata", occup.melt$variable), "order"] = "Mollusca"
occup.melt[grep("Limnodrilus|Lumbriculus|Tubifex", occup.melt$variable), "order"] = "Oligochaeta"
occup.melt[grep("Cypridopsis|Eucypris", occup.melt$variable), "order"] = "Ostracoda"
occup.melt[grep("Ascomorpha|Euchlanis|Kellicottia|Keratella|Ploima|Polyarthra|Synchaeta", occup.melt$variable), "order"] = "Rotifera"
occup.melt[grep("Ceraclea|Hydropsychidae|Psychomiidae|Psychomyia", occup.melt$variable), "order"] = "Trichoptera"
occup.melt[grep("Coenagrionidae", occup.melt$variable), "order"] = "Zygoptera"

cols_barplot = c("red","darkorange", "cyan3", "greenyellow", "plum2", "deeppink", "yellow", "grey50",  "green","blue","palevioletred","aquamarine","goldenrod","khaki4","darkorchid3","gainsboro","tan4")
#, "brown","","black","darkgreen","khaki3",)

png("R_images/barplot_summary_by_order.png", width = 3000, height = 3000, units = "px", res = 300)
ggplot(occup.melt, aes(sample_type, value)) +
  geom_bar(stat="identity", position="fill", aes(fill=order)) +
  scale_fill_manual(values = cols_barplot, name = "") +
  scale_x_discrete(limits=c("kick","eDNA","guts")) +
  theme_bw() +
  facet_grid(time~site) +
  labs(x="", y="Community composition (%)", title = "Community composition (individual taxa grouped by high rank taxonomy)") +
  theme(legend.position = "right")
dev.off()
```

```{r summary barplot of amphipod}
melt.kick = melt(abund.kick)

melt.kick$order = "NA"
melt.kick[grep("Hydracarina|Limnesia|Platynothrus", melt.kick$variable),"order"] = "Arachnida"
melt.kick[grep("Chydorus|Daphnia|Diaphanosoma|Eurycercus|Polyphemus|Sida", melt.kick$variable),"order"] = "Cladocera"
melt.kick[grep("Cyclops|Eucyclops|Eudiaptomus|Maxillopoda|Mesocyclops", melt.kick$variable), "order"] = "Cyclopoida"
melt.kick[grep("Agabus|Dryopidae|Haliplus|Hyphydrus|Limnius|Platambus", melt.kick$variable), "order"] = "Coleoptera"
melt.kick[grep("Asellus", melt.kick$variable), "order"] = "Isopoda"
melt.kick[grep("Corophium|Crangonyx", melt.kick$variable), "order"] = "Amphipoda"
melt.kick[grep("Ceratopogonidae|Chironomidae|Cricotopus|Endochironomus|Limoniidae|Polypedilum|Stratiomys|Tabanidae|Tipulidae", melt.kick$variable), "order"]= "Diptera"
melt.kick[grep("Caenis|Procleon", melt.kick$variable), "order"] = "Ephemeroptera"
melt.kick[grep("Corixidae", melt.kick$variable), "order"] = "Hemiptera"
melt.kick[grep("Bereobdella|Erpobdella|Glossiphonia|Haemopis|Helobdella", melt.kick$variable), "order"] = "Hirudinea"
melt.kick[grep("Hydra", melt.kick$variable), "order"] = "Hydrozoa"
melt.kick[grep("Bithynia|Dreissena|Lymnaea|Pisidium|Planorbis|Potamopyrgus|Segmentina|Sphaerium|Valvata", melt.kick$variable), "order"] = "Mollusca"
melt.kick[grep("Limnodrilus|Lumbriculus|Tubifex", melt.kick$variable), "order"] = "Oligochaeta"
melt.kick[grep("Cypridopsis|Eucypris", melt.kick$variable), "order"] = "Ostracoda"
melt.kick[grep("Ascomorpha|Euchlanis|Kellicottia|Keratella|Ploima|Polyarthra|Synchaeta", melt.kick$variable), "order"] = "Rotifera"
melt.kick[grep("Ceraclea|Hydropsychidae|Psychomiidae|Psychomyia", melt.kick$variable), "order"] = "Trichoptera"
melt.kick[grep("Coenagrionidae", melt.kick$variable), "order"] = "Zygoptera"

col_crustacea = c("olivedrab","springgreen","darkblue","steelblue1","skyblue1","darkorchid2","plum","orchid1","tomato","tan1")

melt.kick[grep("Crangonyx_pseudogracilis", melt.kick$variable),"value"]


png("R_images/barplot_summary_amphipod.png", width = 3000, height = 3000, units = "px", res = 300)
melt.kick[melt.kick$order == "Amphipoda",] %>% 
  mutate(variable = factor(variable, levels=c("Corophium_sp.","Crangonyx_sp.","Crangonyx_floridanus","Crangonyx_pseudogracilis"))) %>% 
  ggplot(aes(sample_id, value, group=time)) +
  geom_bar(stat="identity", position="stack", aes(fill=variable)) +
  scale_fill_manual(values = col_crustacea, name = "") +
  theme_bw() +
  facet_grid(time~., scales="free_x") +
  labs(x="", y="Abundance (count)", title = "Amphipoda kick-samples composition") +
  theme(legend.position = "right")
dev.off()
```

# 8. Niche/Diet breadth

After analysisng the detection of prey species in the gut contents, and after having analysed the communities compositions from eDNA and kick samples. The niche breadth of _D. villosus_ across the 2 invaded sites can be analysed. Further, the comparison of niche overlap between _D. villosus_ and _G. zaddachi_ can be calculated.

```{r niche breadth of amphipods across sites}
# Summing
breadth.cfcp.time = as.data.frame(abund.guts[,!c(colnames(abund.guts) %in% c("sample_type","sample_id","site"))] %>% group_by(predator_id, time) %>% summarise_all(list(sum)))

rownames(breadth.cfcp.time) = paste(breadth.cfcp.time$predator_id, breadth.cfcp.time$time, sep="_")

breadth.cfcp.time = t(breadth.cfcp.time[,!c(colnames(breadth.cfcp.time) %in% c("predator_id","time"))])

niche.dvgz = breadth.cfcp.time

#breadth.cfcp.time[,1] = breadth.cfcp.time[,1]/
#breadth.cfcp.time[,2] = breadth.cfcp.time[,2]/100

niche.width(breadth.cfcp.time, method="levins")
niche.width(breadth.cfcp.time, method="shannon")

# C.floridanus May
(niche.width(breadth.cfcp.time, method="levins")[1]-1)/(nrow(breadth.cfcp.time)-1)
# C.floridanus Oct
(niche.width(breadth.cfcp.time, method="levins")[2]-1)/(nrow(breadth.cfcp.time)-1)
# C.pseudogracilis May
(niche.width(breadth.cfcp.time, method="levins")[3]-1)/(nrow(breadth.cfcp.time)-1)
# C.pseudogracilis Oct
(niche.width(breadth.cfcp.time, method="levins")[4]-1)/(nrow(breadth.cfcp.time)-1)

niche.overlap(breadth.cfcp.time, method="levins")
niche.overlap(breadth.cfcp.time, method="pianka")
```

```{r niche breadth of amphipods species (no sites)}
# summing prey DNA reads by predator ID
breadth.cfcp = as.data.frame(abund.guts[,!c(colnames(abund.guts) %in% c("sample_type","sample_id","site","time"))] %>% group_by(predator_id) %>% summarise_all(list(sum)))

rownames(breadth.cfcp) = breadth.cfcp$predator_id

breadth.cfcp = t(breadth.cfcp[,!c(colnames(breadth.cfcp) %in% c("predator_id"))])

#breadth.cfcp[,1] = breadth.cfcp[,1]/216
#breadth.cfcp[,2] = breadth.cfcp[,2]/107

niche.width(breadth.cfcp, method="levins")
niche.width(breadth.cfcp, method="shannon")

(niche.width(breadth.cfcp, method="levins")[1]-1)/(nrow(breadth.cfcp)-1)
(niche.width(breadth.cfcp, method="levins")[2]-1)/(nrow(breadth.cfcp)-1)

niche.overlap(breadth.cfcp, method="levins")
niche.overlap(breadth.cfcp, method="pianka")
```

# 9. Food web bipartite network

For the bipartite network the gut contents data frame with the detections of preys can now be used. The gut contents data first needs to be summarised by site and season, then the data frame can be transposed to have a matrix with the prey along the rows and the predators along the columns. The prey taxa names (bottom level) will also be simplified from the extended binomial names only to allow a better reading in the bipartite plot.

```{r food web network plus bipartite}
# Summing prey DNA reads by predator ID, site and time.
food.web = as.data.frame(abund.guts[,!c(colnames(abund.guts) %in% c("sample_type","sample_id","site"))] %>% group_by(predator_id, time) %>% summarise_all(list(sum)))
rownames(food.web) = paste(food.web$predator_id, food.web$time, sep="_")

# Removing metadata column and transposing to have predators in columns and prey in rows.
food.web = food.web[,!c(colnames(food.web) %in% c("predator_id","time"))]
food.web = as.data.frame(t(food.web))
#food.web = subset(food.web, subset=rowSums(food.web) > 0)

# Renaming the preys taxa in a more legible format for the plot (e.g. from extended binomial "Asellus aquaticus" to "A.aquaticus")
rownames(food.web) = gsub("[a-z]{3,13}_",".", rownames(food.web))
```

Setting up the order of the top and bottom levels in the bipartite plot, this will allow to colour code the taxa. The taxa in this plot were organised by higher rank (e.g. Diptera, Amphipoda, Oligochaeta, etc.). While the order of the taxa in the plot is organised according to the interactions, in the legend the order was organised by high rank to make it more accessible and easy to read.

```{r plot order}
col.network=c("red","red","red","red","khaki3","khaki3","cyan3","yellow","tan4","tan4","darkorchid3","darkgreen","cyan3","tan4","cyan3")
```

```{r legend order}
name.legend=c("C.multisetosum (Amphipoda)", "Crangonyx  (Amphipoda)", "C.floridanus  (Amphipoda)", "C.pseudogracilis (Amphipoda)", "C.brevilabris (Cladocera)", "D.brachyurum (Cladocera)", "S.crystallina (Cladocera)", "Cyclops (Copepoda)", "C.abyssorum  (Copepoda)", "E.albipennis (Diptera)", "P.antipodarum (Gastropoda)", "L.hoffmeisteri (Oligochaeta)", "L.variegatus (Oligochaeta)", "T.tubifex (Oligochaeta)", "S.polychroa (Tricladida)")

col.legend=c("red","red","red","red","cyan3","cyan3","cyan3","khaki3","khaki3","yellow","darkorchid3","tan4","tan4","tan4","darkgreen")
```

After having set up the orders of taxa in top and bottom levels with their corresponding colours, the bipartite plot and the legend can be generated. The legend was generated separately due to limits in the plot dimensions, which if reduced would have made either the plot, or the legend non readable. The legend and the plot were merged externally to R.

```{r plotting the networks}
# Producing the bipartite network
png("R_images/bipartite_network.png", width=4000, height=2500, units="px", res=300)
plotweb(food.web, y.width.low=0.1, y.width.high=0.08,	y.lim=c(0,3), labsize=2, low.lablength=5, low.lab.dis=0.1, high.lab.dis=0.1, low.spacing=0.012, high.spacing = 0.07, text.rot=90, col.high="black", col.low=col.network)
dev.off()

# Producing the legend
png("R_images/bipartite_network_legend.png", width=4000, height=2500, units="px", res=300)
plotweb(food.web,high.plot=F, low.plot=F, col.interaction = "white", bor.col.interaction = "white")
legend("center", xpd=T, legend=name.legend, fill=col.legend, bty="n", border="black")
dev.off()
```

```{r log session info}
sink("log_session_analysis.txt")
sessionInfo()
citation()
sink()
```

```{r packages citation}
sink("packages_citations.txt")
for (p in pack.list){
 print(citation(p))
}
sink()
```

```{r}
print("end")
```

## TO DO

* eDNA for the community estimate
* improve the plots and the stats
* PERMANOVA
* seasonality!
* web parameters!